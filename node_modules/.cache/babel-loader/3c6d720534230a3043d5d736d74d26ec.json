{"ast":null,"code":"import { BackSide, DoubleSide, CubeUVRefractionMapping, CubeUVReflectionMapping, ObjectSpaceNormalMap, TangentSpaceNormalMap, NoToneMapping, LinearEncoding, sRGBEncoding } from '../../constants.js';\nimport { Layers } from '../../core/Layers.js';\nimport { WebGLProgram } from './WebGLProgram.js';\nimport { WebGLShaderCache } from './WebGLShaderCache.js';\nimport { ShaderLib } from '../shaders/ShaderLib.js';\nimport { UniformsUtils } from '../shaders/UniformsUtils.js';\n\nfunction WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {\n  const _programLayers = new Layers();\n\n  const _customShaders = new WebGLShaderCache();\n\n  const programs = [];\n  const isWebGL2 = capabilities.isWebGL2;\n  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  const floatVertexTextures = capabilities.floatVertexTextures;\n  const maxVertexUniforms = capabilities.maxVertexUniforms;\n  const vertexTextures = capabilities.vertexTextures;\n  let precision = capabilities.precision;\n  const shaderIDs = {\n    MeshDepthMaterial: 'depth',\n    MeshDistanceMaterial: 'distanceRGBA',\n    MeshNormalMaterial: 'normal',\n    MeshBasicMaterial: 'basic',\n    MeshLambertMaterial: 'lambert',\n    MeshPhongMaterial: 'phong',\n    MeshToonMaterial: 'toon',\n    MeshStandardMaterial: 'physical',\n    MeshPhysicalMaterial: 'physical',\n    MeshMatcapMaterial: 'matcap',\n    LineBasicMaterial: 'basic',\n    LineDashedMaterial: 'dashed',\n    PointsMaterial: 'points',\n    ShadowMaterial: 'shadow',\n    SpriteMaterial: 'sprite'\n  };\n\n  function getMaxBones(object) {\n    const skeleton = object.skeleton;\n    const bones = skeleton.bones;\n\n    if (floatVertexTextures) {\n      return 1024;\n    } else {\n      // default for when object is not specified\n      // ( for example when prebuilding shader to be used with multiple objects )\n      //\n      //  - leave some extra space for other uniforms\n      //  - limit here is ANGLE's 254 max uniform vectors\n      //    (up to 54 should be safe)\n      const nVertexUniforms = maxVertexUniforms;\n      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n      const maxBones = Math.min(nVertexMatrices, bones.length);\n\n      if (maxBones < bones.length) {\n        console.warn('THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.');\n        return 0;\n      }\n\n      return maxBones;\n    }\n  }\n\n  function getParameters(material, lights, shadows, scene, object) {\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);\n    const shaderID = shaderIDs[material.type]; // heuristics to create shader parameters according to lights in the scene\n    // (not to blow over maxLights budget)\n\n    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n\n      if (precision !== material.precision) {\n        console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.');\n      }\n    }\n\n    let vertexShader, fragmentShader;\n    let customVertexShaderID, customFragmentShaderID;\n\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      vertexShader = shader.vertexShader;\n      fragmentShader = shader.fragmentShader;\n    } else {\n      vertexShader = material.vertexShader;\n      fragmentShader = material.fragmentShader;\n\n      _customShaders.update(material);\n\n      customVertexShaderID = _customShaders.getVertexShaderID(material);\n      customFragmentShaderID = _customShaders.getFragmentShaderID(material);\n    }\n\n    const currentRenderTarget = renderer.getRenderTarget();\n    const useAlphaTest = material.alphaTest > 0;\n    const useClearcoat = material.clearcoat > 0;\n    const parameters = {\n      isWebGL2: isWebGL2,\n      shaderID: shaderID,\n      shaderName: material.type,\n      vertexShader: vertexShader,\n      fragmentShader: fragmentShader,\n      defines: material.defines,\n      customVertexShaderID: customVertexShaderID,\n      customFragmentShaderID: customFragmentShaderID,\n      isRawShaderMaterial: material.isRawShaderMaterial === true,\n      glslVersion: material.glslVersion,\n      precision: precision,\n      instancing: object.isInstancedMesh === true,\n      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n      supportsVertexTextures: vertexTextures,\n      outputEncoding: currentRenderTarget === null ? renderer.outputEncoding : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.encoding : LinearEncoding,\n      map: !!material.map,\n      matcap: !!material.matcap,\n      envMap: !!envMap,\n      envMapMode: envMap && envMap.mapping,\n      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),\n      lightMap: !!material.lightMap,\n      aoMap: !!material.aoMap,\n      emissiveMap: !!material.emissiveMap,\n      bumpMap: !!material.bumpMap,\n      normalMap: !!material.normalMap,\n      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n      decodeVideoTexture: !!material.map && material.map.isVideoTexture === true && material.map.encoding === sRGBEncoding,\n      clearcoat: useClearcoat,\n      clearcoatMap: useClearcoat && !!material.clearcoatMap,\n      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,\n      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,\n      displacementMap: !!material.displacementMap,\n      roughnessMap: !!material.roughnessMap,\n      metalnessMap: !!material.metalnessMap,\n      specularMap: !!material.specularMap,\n      specularIntensityMap: !!material.specularIntensityMap,\n      specularColorMap: !!material.specularColorMap,\n      transparent: material.transparent,\n      alphaMap: !!material.alphaMap,\n      alphaTest: useAlphaTest,\n      gradientMap: !!material.gradientMap,\n      sheen: material.sheen > 0,\n      sheenColorMap: !!material.sheenColorMap,\n      sheenRoughnessMap: !!material.sheenRoughnessMap,\n      transmission: material.transmission > 0,\n      transmissionMap: !!material.transmissionMap,\n      thicknessMap: !!material.thicknessMap,\n      combine: material.combine,\n      vertexTangents: !!material.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,\n      vertexColors: material.vertexColors,\n      vertexAlphas: material.vertexColors === true && !!object.geometry && !!object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || !!material.sheenColorMap || !!material.sheenRoughnessMap,\n      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || material.transmission > 0 || !!material.transmissionMap || !!material.thicknessMap || !!material.specularIntensityMap || !!material.specularColorMap || material.sheen > 0 || !!material.sheenColorMap || !!material.sheenRoughnessMap) && !!material.displacementMap,\n      fog: !!fog,\n      useFog: material.fog,\n      fogExp2: fog && fog.isFogExp2,\n      flatShading: !!material.flatShading,\n      sizeAttenuation: material.sizeAttenuation,\n      logarithmicDepthBuffer: logarithmicDepthBuffer,\n      skinning: object.isSkinnedMesh === true && maxBones > 0,\n      maxBones: maxBones,\n      useVertexTexture: floatVertexTextures,\n      morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,\n      morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,\n      morphTargetsCount: !!object.geometry && !!object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,\n      numDirLights: lights.directional.length,\n      numPointLights: lights.point.length,\n      numSpotLights: lights.spot.length,\n      numRectAreaLights: lights.rectArea.length,\n      numHemiLights: lights.hemi.length,\n      numDirLightShadows: lights.directionalShadowMap.length,\n      numPointLightShadows: lights.pointShadowMap.length,\n      numSpotLightShadows: lights.spotShadowMap.length,\n      numClippingPlanes: clipping.numPlanes,\n      numClipIntersection: clipping.numIntersection,\n      dithering: material.dithering,\n      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n      shadowMapType: renderer.shadowMap.type,\n      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n      physicallyCorrectLights: renderer.physicallyCorrectLights,\n      premultipliedAlpha: material.premultipliedAlpha,\n      doubleSided: material.side === DoubleSide,\n      flipSided: material.side === BackSide,\n      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,\n      index0AttributeName: material.index0AttributeName,\n      extensionDerivatives: material.extensions && material.extensions.derivatives,\n      extensionFragDepth: material.extensions && material.extensions.fragDepth,\n      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),\n      rendererExtensionDrawBuffers: isWebGL2 || extensions.has('WEBGL_draw_buffers'),\n      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has('EXT_shader_texture_lod'),\n      customProgramCacheKey: material.customProgramCacheKey()\n    };\n    return parameters;\n  }\n\n  function getProgramCacheKey(parameters) {\n    const array = [];\n\n    if (parameters.shaderID) {\n      array.push(parameters.shaderID);\n    } else {\n      array.push(parameters.customVertexShaderID);\n      array.push(parameters.customFragmentShaderID);\n    }\n\n    if (parameters.defines !== undefined) {\n      for (const name in parameters.defines) {\n        array.push(name);\n        array.push(parameters.defines[name]);\n      }\n    }\n\n    if (parameters.isRawShaderMaterial === false) {\n      getProgramCacheKeyParameters(array, parameters);\n      getProgramCacheKeyBooleans(array, parameters);\n      array.push(renderer.outputEncoding);\n    }\n\n    array.push(parameters.customProgramCacheKey);\n    return array.join();\n  }\n\n  function getProgramCacheKeyParameters(array, parameters) {\n    array.push(parameters.precision);\n    array.push(parameters.outputEncoding);\n    array.push(parameters.envMapMode);\n    array.push(parameters.combine);\n    array.push(parameters.vertexUvs);\n    array.push(parameters.fogExp2);\n    array.push(parameters.sizeAttenuation);\n    array.push(parameters.maxBones);\n    array.push(parameters.morphTargetsCount);\n    array.push(parameters.numDirLights);\n    array.push(parameters.numPointLights);\n    array.push(parameters.numSpotLights);\n    array.push(parameters.numHemiLights);\n    array.push(parameters.numRectAreaLights);\n    array.push(parameters.numDirLightShadows);\n    array.push(parameters.numPointLightShadows);\n    array.push(parameters.numSpotLightShadows);\n    array.push(parameters.shadowMapType);\n    array.push(parameters.toneMapping);\n    array.push(parameters.numClippingPlanes);\n    array.push(parameters.numClipIntersection);\n  }\n\n  function getProgramCacheKeyBooleans(array, parameters) {\n    _programLayers.disableAll();\n\n    if (parameters.isWebGL2) _programLayers.enable(0);\n    if (parameters.supportsVertexTextures) _programLayers.enable(1);\n    if (parameters.instancing) _programLayers.enable(2);\n    if (parameters.instancingColor) _programLayers.enable(3);\n    if (parameters.map) _programLayers.enable(4);\n    if (parameters.matcap) _programLayers.enable(5);\n    if (parameters.envMap) _programLayers.enable(6);\n    if (parameters.envMapCubeUV) _programLayers.enable(7);\n    if (parameters.lightMap) _programLayers.enable(8);\n    if (parameters.aoMap) _programLayers.enable(9);\n    if (parameters.emissiveMap) _programLayers.enable(10);\n    if (parameters.bumpMap) _programLayers.enable(11);\n    if (parameters.normalMap) _programLayers.enable(12);\n    if (parameters.objectSpaceNormalMap) _programLayers.enable(13);\n    if (parameters.tangentSpaceNormalMap) _programLayers.enable(14);\n    if (parameters.clearcoat) _programLayers.enable(15);\n    if (parameters.clearcoatMap) _programLayers.enable(16);\n    if (parameters.clearcoatRoughnessMap) _programLayers.enable(17);\n    if (parameters.clearcoatNormalMap) _programLayers.enable(18);\n    if (parameters.displacementMap) _programLayers.enable(19);\n    if (parameters.specularMap) _programLayers.enable(20);\n    if (parameters.roughnessMap) _programLayers.enable(21);\n    if (parameters.metalnessMap) _programLayers.enable(22);\n    if (parameters.gradientMap) _programLayers.enable(23);\n    if (parameters.alphaMap) _programLayers.enable(24);\n    if (parameters.alphaTest) _programLayers.enable(25);\n    if (parameters.vertexColors) _programLayers.enable(26);\n    if (parameters.vertexAlphas) _programLayers.enable(27);\n    if (parameters.vertexUvs) _programLayers.enable(28);\n    if (parameters.vertexTangents) _programLayers.enable(29);\n    if (parameters.uvsVertexOnly) _programLayers.enable(30);\n    if (parameters.fog) _programLayers.enable(31);\n    array.push(_programLayers.mask);\n\n    _programLayers.disableAll();\n\n    if (parameters.useFog) _programLayers.enable(0);\n    if (parameters.flatShading) _programLayers.enable(1);\n    if (parameters.logarithmicDepthBuffer) _programLayers.enable(2);\n    if (parameters.skinning) _programLayers.enable(3);\n    if (parameters.useVertexTexture) _programLayers.enable(4);\n    if (parameters.morphTargets) _programLayers.enable(5);\n    if (parameters.morphNormals) _programLayers.enable(6);\n    if (parameters.premultipliedAlpha) _programLayers.enable(7);\n    if (parameters.shadowMapEnabled) _programLayers.enable(8);\n    if (parameters.physicallyCorrectLights) _programLayers.enable(9);\n    if (parameters.doubleSided) _programLayers.enable(10);\n    if (parameters.flipSided) _programLayers.enable(11);\n    if (parameters.depthPacking) _programLayers.enable(12);\n    if (parameters.dithering) _programLayers.enable(13);\n    if (parameters.specularIntensityMap) _programLayers.enable(14);\n    if (parameters.specularColorMap) _programLayers.enable(15);\n    if (parameters.transmission) _programLayers.enable(16);\n    if (parameters.transmissionMap) _programLayers.enable(17);\n    if (parameters.thicknessMap) _programLayers.enable(18);\n    if (parameters.sheen) _programLayers.enable(19);\n    if (parameters.sheenColorMap) _programLayers.enable(20);\n    if (parameters.sheenRoughnessMap) _programLayers.enable(21);\n    if (parameters.decodeVideoTexture) _programLayers.enable(22);\n    if (parameters.transparent) _programLayers.enable(23);\n    array.push(_programLayers.mask);\n  }\n\n  function getUniforms(material) {\n    const shaderID = shaderIDs[material.type];\n    let uniforms;\n\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      uniforms = UniformsUtils.clone(shader.uniforms);\n    } else {\n      uniforms = material.uniforms;\n    }\n\n    return uniforms;\n  }\n\n  function acquireProgram(parameters, cacheKey) {\n    let program; // Check if code has been already compiled\n\n    for (let p = 0, pl = programs.length; p < pl; p++) {\n      const preexistingProgram = programs[p];\n\n      if (preexistingProgram.cacheKey === cacheKey) {\n        program = preexistingProgram;\n        ++program.usedTimes;\n        break;\n      }\n    }\n\n    if (program === undefined) {\n      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n      programs.push(program);\n    }\n\n    return program;\n  }\n\n  function releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      // Remove from unordered set\n      const i = programs.indexOf(program);\n      programs[i] = programs[programs.length - 1];\n      programs.pop(); // Free WebGL resources\n\n      program.destroy();\n    }\n  }\n\n  function releaseShaderCache(material) {\n    _customShaders.remove(material);\n  }\n\n  function dispose() {\n    _customShaders.dispose();\n  }\n\n  return {\n    getParameters: getParameters,\n    getProgramCacheKey: getProgramCacheKey,\n    getUniforms: getUniforms,\n    acquireProgram: acquireProgram,\n    releaseProgram: releaseProgram,\n    releaseShaderCache: releaseShaderCache,\n    // Exposed for resource monitoring & error feedback via renderer.info:\n    programs: programs,\n    dispose: dispose\n  };\n}\n\nexport { WebGLPrograms };","map":null,"metadata":{},"sourceType":"module"}