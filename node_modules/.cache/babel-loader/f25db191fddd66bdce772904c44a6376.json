{"ast":null,"code":"import { LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, RGBAFormat, DepthFormat, DepthStencilFormat, UnsignedShortType, UnsignedIntType, UnsignedInt248Type, FloatType, HalfFloatType, MirroredRepeatWrapping, ClampToEdgeWrapping, RepeatWrapping, sRGBEncoding, LinearEncoding, UnsignedByteType, _SRGBAFormat } from '../../constants.js';\nimport * as MathUtils from '../../math/MathUtils.js';\nimport { ImageUtils } from '../../extras/ImageUtils.js';\nimport { createElementNS } from '../../utils.js';\n\nfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const maxTextures = capabilities.maxTextures;\n  const maxCubemapSize = capabilities.maxCubemapSize;\n  const maxTextureSize = capabilities.maxTextureSize;\n  const maxSamples = capabilities.maxSamples;\n  const hasMultisampledRenderToTexture = extensions.has('WEBGL_multisampled_render_to_texture');\n  const MultisampledRenderToTextureExtension = hasMultisampledRenderToTexture ? extensions.get('WEBGL_multisampled_render_to_texture') : undefined;\n\n  const _videoTextures = new WeakMap();\n\n  let _canvas; // cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,\n  // also OffscreenCanvas.getContext(\"webgl\"), but not OffscreenCanvas.getContext(\"2d\")!\n  // Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).\n\n\n  let useOffscreenCanvas = false;\n\n  try {\n    useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && new OffscreenCanvas(1, 1).getContext('2d') !== null;\n  } catch (err) {// Ignore any errors\n  }\n\n  function createCanvas(width, height) {\n    // Use OffscreenCanvas when available. Specially needed in web workers\n    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS('canvas');\n  }\n\n  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n    let scale = 1; // handle case if texture exceeds max size\n\n    if (image.width > maxSize || image.height > maxSize) {\n      scale = maxSize / Math.max(image.width, image.height);\n    } // only perform resize if necessary\n\n\n    if (scale < 1 || needsPowerOfTwo === true) {\n      // only perform resize for certain image types\n      if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n        const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;\n        const width = floor(scale * image.width);\n        const height = floor(scale * image.height);\n        if (_canvas === undefined) _canvas = createCanvas(width, height); // cube textures can't reuse the same canvas\n\n        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;\n        canvas.width = width;\n        canvas.height = height;\n        const context = canvas.getContext('2d');\n        context.drawImage(image, 0, 0, width, height);\n        console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');\n        return canvas;\n      } else {\n        if ('data' in image) {\n          console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').');\n        }\n\n        return image;\n      }\n    }\n\n    return image;\n  }\n\n  function isPowerOfTwo(image) {\n    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);\n  }\n\n  function textureNeedsPowerOfTwo(texture) {\n    if (isWebGL2) return false;\n    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n\n  function textureNeedsGenerateMipmaps(texture, supportsMips) {\n    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n\n  function generateMipmap(target) {\n    _gl.generateMipmap(target);\n  }\n\n  function getInternalFormat(internalFormatName, glFormat, glType, encoding) {\n    let isVideoTexture = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n    if (isWebGL2 === false) return glFormat;\n\n    if (internalFormatName !== null) {\n      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];\n      console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \\'' + internalFormatName + '\\'');\n    }\n\n    let internalFormat = glFormat;\n\n    if (glFormat === _gl.RED) {\n      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;\n      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;\n    }\n\n    if (glFormat === _gl.RG) {\n      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;\n      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;\n    }\n\n    if (glFormat === _gl.RGBA) {\n      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;\n      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;\n      if (glType === _gl.UNSIGNED_BYTE) internalFormat = encoding === sRGBEncoding && isVideoTexture === false ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;\n      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;\n      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;\n    }\n\n    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {\n      extensions.get('EXT_color_buffer_float');\n    }\n\n    return internalFormat;\n  }\n\n  function getMipLevels(texture, image, supportsMips) {\n    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n      return Math.log2(Math.max(image.width, image.height)) + 1;\n    } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {\n      // user-defined mipmaps\n      return texture.mipmaps.length;\n    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {\n      return image.mipmaps.length;\n    } else {\n      // texture without mipmaps (only base level)\n      return 1;\n    }\n  } // Fallback filters for non-power-of-2 textures\n\n\n  function filterFallback(f) {\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return _gl.NEAREST;\n    }\n\n    return _gl.LINEAR;\n  } //\n\n\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener('dispose', onTextureDispose);\n    deallocateTexture(texture);\n\n    if (texture.isVideoTexture) {\n      _videoTextures.delete(texture);\n    }\n\n    info.memory.textures--;\n  }\n\n  function onRenderTargetDispose(event) {\n    const renderTarget = event.target;\n    renderTarget.removeEventListener('dispose', onRenderTargetDispose);\n    deallocateRenderTarget(renderTarget);\n  } //\n\n\n  function deallocateTexture(texture) {\n    const textureProperties = properties.get(texture);\n    if (textureProperties.__webglInit === undefined) return;\n\n    _gl.deleteTexture(textureProperties.__webglTexture);\n\n    properties.remove(texture);\n  }\n\n  function deallocateRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    if (!renderTarget) return;\n\n    if (textureProperties.__webglTexture !== undefined) {\n      _gl.deleteTexture(textureProperties.__webglTexture);\n\n      info.memory.textures--;\n    }\n\n    if (renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n    }\n\n    if (renderTarget.isWebGLCubeRenderTarget) {\n      for (let i = 0; i < 6; i++) {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n\n        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n      }\n    } else {\n      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n\n      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n      if (renderTargetProperties.__webglColorRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    }\n\n    if (renderTarget.isWebGLMultipleRenderTargets) {\n      for (let i = 0, il = texture.length; i < il; i++) {\n        const attachmentProperties = properties.get(texture[i]);\n\n        if (attachmentProperties.__webglTexture) {\n          _gl.deleteTexture(attachmentProperties.__webglTexture);\n\n          info.memory.textures--;\n        }\n\n        properties.remove(texture[i]);\n      }\n    }\n\n    properties.remove(texture);\n    properties.remove(renderTarget);\n  } //\n\n\n  let textureUnits = 0;\n\n  function resetTextureUnits() {\n    textureUnits = 0;\n  }\n\n  function allocateTextureUnit() {\n    const textureUnit = textureUnits;\n\n    if (textureUnit >= maxTextures) {\n      console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures);\n    }\n\n    textureUnits += 1;\n    return textureUnit;\n  } //\n\n\n  function setTexture2D(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.isVideoTexture) updateVideoTexture(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      const image = texture.image;\n\n      if (image === undefined) {\n        console.warn('THREE.WebGLRenderer: Texture marked for update but image is undefined');\n      } else if (image.complete === false) {\n        console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete');\n      } else {\n        uploadTexture(textureProperties, texture, slot);\n        return;\n      }\n    }\n\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture);\n  }\n\n  function setTexture2DArray(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture);\n  }\n\n  function setTexture3D(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture);\n  }\n\n  function setTextureCube(texture, slot) {\n    const textureProperties = properties.get(texture);\n\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadCubeTexture(textureProperties, texture, slot);\n      return;\n    }\n\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n  }\n\n  const wrappingToGL = {\n    [RepeatWrapping]: _gl.REPEAT,\n    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,\n    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT\n  };\n  const filterToGL = {\n    [NearestFilter]: _gl.NEAREST,\n    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,\n    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,\n    [LinearFilter]: _gl.LINEAR,\n    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,\n    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR\n  };\n\n  function setTextureParameters(textureType, texture, supportsMips) {\n    if (supportsMips) {\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);\n\n      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);\n      }\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);\n    } else {\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);\n\n      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {\n        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);\n      }\n\n      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.');\n      }\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));\n\n      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));\n\n      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n        console.warn('THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.');\n      }\n    }\n\n    if (extensions.has('EXT_texture_filter_anisotropic') === true) {\n      const extension = extensions.get('EXT_texture_filter_anisotropic');\n      if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2\n\n      if (isWebGL2 === false && texture.type === HalfFloatType && extensions.has('OES_texture_half_float_linear') === false) return; // verify extension for WebGL 1 only\n\n      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n\n  function initTexture(textureProperties, texture) {\n    if (textureProperties.__webglInit === undefined) {\n      textureProperties.__webglInit = true;\n      texture.addEventListener('dispose', onTextureDispose);\n      textureProperties.__webglTexture = _gl.createTexture();\n      info.memory.textures++;\n    }\n  }\n\n  function uploadTexture(textureProperties, texture, slot) {\n    let textureType = _gl.TEXTURE_2D;\n    if (texture.isDataTexture2DArray) textureType = _gl.TEXTURE_2D_ARRAY;\n    if (texture.isDataTexture3D) textureType = _gl.TEXTURE_3D;\n    initTexture(textureProperties, texture);\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(textureType, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n    _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;\n    let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n    image = verifyColorSpace(texture, image);\n    const supportsMips = isPowerOfTwo(image) || isWebGL2,\n          glFormat = utils.convert(texture.format, texture.encoding);\n    let glType = utils.convert(texture.type),\n        glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding, texture.isVideoTexture);\n    setTextureParameters(textureType, texture, supportsMips);\n    let mipmap;\n    const mipmaps = texture.mipmaps;\n    const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;\n    const allocateMemory = textureProperties.__version === undefined;\n    const levels = getMipLevels(texture, image, supportsMips);\n\n    if (texture.isDepthTexture) {\n      // populate depth texture with dummy data\n      glInternalFormat = _gl.DEPTH_COMPONENT;\n\n      if (isWebGL2) {\n        if (texture.type === FloatType) {\n          glInternalFormat = _gl.DEPTH_COMPONENT32F;\n        } else if (texture.type === UnsignedIntType) {\n          glInternalFormat = _gl.DEPTH_COMPONENT24;\n        } else if (texture.type === UnsignedInt248Type) {\n          glInternalFormat = _gl.DEPTH24_STENCIL8;\n        } else {\n          glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D\n        }\n      } else {\n        if (texture.type === FloatType) {\n          console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');\n        }\n      } // validation checks for WebGL 1\n\n\n      if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n        // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n        // DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n          console.warn('THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.');\n          texture.type = UnsignedShortType;\n          glType = utils.convert(texture.type);\n        }\n      }\n\n      if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {\n        // Depth stencil textures need the DEPTH_STENCIL internal format\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n        glInternalFormat = _gl.DEPTH_STENCIL; // The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\n        // DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\n        // (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\n\n        if (texture.type !== UnsignedInt248Type) {\n          console.warn('THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.');\n          texture.type = UnsignedInt248Type;\n          glType = utils.convert(texture.type);\n        }\n      } //\n\n\n      if (useTexStorage && allocateMemory) {\n        state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);\n      } else {\n        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n      }\n    } else if (texture.isDataTexture) {\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n      if (mipmaps.length > 0 && supportsMips) {\n        if (useTexStorage && allocateMemory) {\n          state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n        }\n\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n\n          if (useTexStorage) {\n            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n          } else {\n            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n          }\n        }\n\n        texture.generateMipmaps = false;\n      } else {\n        if (useTexStorage) {\n          if (allocateMemory) {\n            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);\n          }\n\n          state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);\n        } else {\n          state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n        }\n      }\n    } else if (texture.isCompressedTexture) {\n      if (useTexStorage && allocateMemory) {\n        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n      }\n\n      for (let i = 0, il = mipmaps.length; i < il; i++) {\n        mipmap = mipmaps[i];\n\n        if (texture.format !== RGBAFormat) {\n          if (glFormat !== null) {\n            if (useTexStorage) {\n              state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n            } else {\n              state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n            }\n          } else {\n            console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');\n          }\n        } else {\n          if (useTexStorage) {\n            state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n          } else {\n            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n          }\n        }\n      }\n    } else if (texture.isDataTexture2DArray) {\n      if (useTexStorage) {\n        if (allocateMemory) {\n          state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);\n        }\n\n        state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n      } else {\n        state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n      }\n    } else if (texture.isDataTexture3D) {\n      if (useTexStorage) {\n        if (allocateMemory) {\n          state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);\n        }\n\n        state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);\n      } else {\n        state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n      }\n    } else if (texture.isFramebufferTexture) {\n      if (useTexStorage && allocateMemory) {\n        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);\n      } else {\n        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n      }\n    } else {\n      // regular Texture (image, video, canvas)\n      // use manually created mipmaps if available\n      // if there are no manual mipmaps\n      // set 0 level mipmap and then use GL to generate other mipmap levels\n      if (mipmaps.length > 0 && supportsMips) {\n        if (useTexStorage && allocateMemory) {\n          state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);\n        }\n\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n\n          if (useTexStorage) {\n            state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);\n          } else {\n            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);\n          }\n        }\n\n        texture.generateMipmaps = false;\n      } else {\n        if (useTexStorage) {\n          if (allocateMemory) {\n            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);\n          }\n\n          state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);\n        } else {\n          state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);\n        }\n      }\n    }\n\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      generateMipmap(textureType);\n    }\n\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  }\n\n  function uploadCubeTexture(textureProperties, texture, slot) {\n    if (texture.image.length !== 6) return;\n    initTexture(textureProperties, texture);\n    state.activeTexture(_gl.TEXTURE0 + slot);\n    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n\n    _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);\n\n    _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);\n\n    _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);\n\n    _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE);\n\n    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n    const cubeImage = [];\n\n    for (let i = 0; i < 6; i++) {\n      if (!isCompressed && !isDataTexture) {\n        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);\n      } else {\n        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n      }\n\n      cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);\n    }\n\n    const image = cubeImage[0],\n          supportsMips = isPowerOfTwo(image) || isWebGL2,\n          glFormat = utils.convert(texture.format, texture.encoding),\n          glType = utils.convert(texture.type),\n          glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n    const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;\n    const allocateMemory = textureProperties.__version === undefined;\n    let levels = getMipLevels(texture, image, supportsMips);\n    setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n    let mipmaps;\n\n    if (isCompressed) {\n      if (useTexStorage && allocateMemory) {\n        state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);\n      }\n\n      for (let i = 0; i < 6; i++) {\n        mipmaps = cubeImage[i].mipmaps;\n\n        for (let j = 0; j < mipmaps.length; j++) {\n          const mipmap = mipmaps[j];\n\n          if (texture.format !== RGBAFormat) {\n            if (glFormat !== null) {\n              if (useTexStorage) {\n                state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);\n              } else {\n                state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n              }\n            } else {\n              console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()');\n            }\n          } else {\n            if (useTexStorage) {\n              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);\n            } else {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n            }\n          }\n        }\n      }\n    } else {\n      mipmaps = texture.mipmaps;\n\n      if (useTexStorage && allocateMemory) {\n        // TODO: Uniformly handle mipmap definitions\n        // Normal textures and compressed cube textures define base level + mips with their mipmap array\n        // Uncompressed cube textures use their mipmap array only for mips (no base level)\n        if (mipmaps.length > 0) levels++;\n        state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);\n      }\n\n      for (let i = 0; i < 6; i++) {\n        if (isDataTexture) {\n          if (useTexStorage) {\n            state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);\n          } else {\n            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n          }\n\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            const mipmapImage = mipmap.image[i].image;\n\n            if (useTexStorage) {\n              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);\n            } else {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n            }\n          }\n        } else {\n          if (useTexStorage) {\n            state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);\n          } else {\n            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n          }\n\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n\n            if (useTexStorage) {\n              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);\n            } else {\n              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n            }\n          }\n        }\n      }\n    }\n\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      // We assume images for cube map have the same size.\n      generateMipmap(_gl.TEXTURE_CUBE_MAP);\n    }\n\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate) texture.onUpdate(texture);\n  } // Render targets\n  // Setup storage for target texture and bind it to correct framebuffer\n\n\n  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget) {\n    const glFormat = utils.convert(texture.format, texture.encoding);\n    const glType = utils.convert(texture.type);\n    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n    const renderTargetProperties = properties.get(renderTarget);\n\n    if (!renderTargetProperties.__hasExternalTextures) {\n      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {\n        state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n      } else {\n        state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n      }\n    }\n\n    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n    if (renderTarget.useRenderToTexture) {\n      MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));\n    } else {\n      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n    }\n\n    state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n  } // Setup storage for internal depth/stencil buffers and bind to correct framebuffer\n\n\n  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);\n\n    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n      let glInternalFormat = _gl.DEPTH_COMPONENT16;\n\n      if (isMultisample || renderTarget.useRenderToTexture) {\n        const depthTexture = renderTarget.depthTexture;\n\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === FloatType) {\n            glInternalFormat = _gl.DEPTH_COMPONENT32F;\n          } else if (depthTexture.type === UnsignedIntType) {\n            glInternalFormat = _gl.DEPTH_COMPONENT24;\n          }\n        }\n\n        const samples = getRenderTargetSamples(renderTarget);\n\n        if (renderTarget.useRenderToTexture) {\n          MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        } else {\n          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n        }\n      } else {\n        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n\n      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n      const samples = getRenderTargetSamples(renderTarget);\n\n      if (isMultisample && renderTarget.useRenderbuffer) {\n        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);\n      } else if (renderTarget.useRenderToTexture) {\n        MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);\n      }\n\n      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);\n    } else {\n      // Use the first texture for MRT so far\n      const texture = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture[0] : renderTarget.texture;\n      const glFormat = utils.convert(texture.format, texture.encoding);\n      const glType = utils.convert(texture.type);\n      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n      const samples = getRenderTargetSamples(renderTarget);\n\n      if (isMultisample && renderTarget.useRenderbuffer) {\n        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else if (renderTarget.useRenderToTexture) {\n        MultisampledRenderToTextureExtension.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n    }\n\n    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n  } // Setup resources for a Depth Texture for a FBO (needs an extension)\n\n\n  function setupDepthTexture(framebuffer, renderTarget) {\n    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube) throw new Error('Depth Texture with cube render targets is not supported');\n    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);\n\n    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n      throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\n    } // upload an empty depth texture with framebuffer size\n\n\n    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n      renderTarget.depthTexture.image.width = renderTarget.width;\n      renderTarget.depthTexture.image.height = renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n    }\n\n    setTexture2D(renderTarget.depthTexture, 0);\n\n    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n\n    const samples = getRenderTargetSamples(renderTarget);\n\n    if (renderTarget.depthTexture.format === DepthFormat) {\n      if (renderTarget.useRenderToTexture) {\n        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);\n      } else {\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n      }\n    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      if (renderTarget.useRenderToTexture) {\n        MultisampledRenderToTextureExtension.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);\n      } else {\n        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);\n      }\n    } else {\n      throw new Error('Unknown depthTexture format');\n    }\n  } // Setup GL resources for a non-texture depth buffer\n\n\n  function setupDepthRenderbuffer(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n\n    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {\n      if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');\n      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n    } else {\n      if (isCube) {\n        renderTargetProperties.__webglDepthbuffer = [];\n\n        for (let i = 0; i < 6; i++) {\n          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);\n          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n        }\n      } else {\n        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n      }\n    }\n\n    state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n  } // rebind framebuffer with external textures\n\n\n  function rebindTextures(renderTarget, colorTexture, depthTexture) {\n    const renderTargetProperties = properties.get(renderTarget);\n\n    if (colorTexture !== undefined) {\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D);\n    }\n\n    if (depthTexture !== undefined) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  } // Set up GL resources for the render target\n\n\n  function setupRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    renderTarget.addEventListener('dispose', onRenderTargetDispose);\n\n    if (renderTarget.isWebGLMultipleRenderTargets !== true) {\n      if (textureProperties.__webglTexture === undefined) {\n        textureProperties.__webglTexture = _gl.createTexture();\n      }\n\n      textureProperties.__version = texture.version;\n      info.memory.textures++;\n    }\n\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;\n    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2; // Setup framebuffer\n\n    if (isCube) {\n      renderTargetProperties.__webglFramebuffer = [];\n\n      for (let i = 0; i < 6; i++) {\n        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n      }\n    } else {\n      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n\n      if (isMultipleRenderTargets) {\n        if (capabilities.drawBuffers) {\n          const textures = renderTarget.texture;\n\n          for (let i = 0, il = textures.length; i < il; i++) {\n            const attachmentProperties = properties.get(textures[i]);\n\n            if (attachmentProperties.__webglTexture === undefined) {\n              attachmentProperties.__webglTexture = _gl.createTexture();\n              info.memory.textures++;\n            }\n          }\n        } else {\n          console.warn('THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.');\n        }\n      } else if (renderTarget.useRenderbuffer) {\n        if (isWebGL2) {\n          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n\n          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n          const glFormat = utils.convert(texture.format, texture.encoding);\n          const glType = utils.convert(texture.type);\n          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.encoding);\n          const samples = getRenderTargetSamples(renderTarget);\n\n          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n\n          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n\n          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer);\n\n          _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);\n\n          if (renderTarget.depthBuffer) {\n            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n          }\n\n          state.bindFramebuffer(_gl.FRAMEBUFFER, null);\n        } else {\n          console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n        }\n      }\n    } // Setup color buffer\n\n\n    if (isCube) {\n      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);\n      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);\n\n      for (let i = 0; i < 6; i++) {\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i);\n      }\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(_gl.TEXTURE_CUBE_MAP);\n      }\n\n      state.unbindTexture();\n    } else if (isMultipleRenderTargets) {\n      const textures = renderTarget.texture;\n\n      for (let i = 0, il = textures.length; i < il; i++) {\n        const attachment = textures[i];\n        const attachmentProperties = properties.get(attachment);\n        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);\n        setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D);\n\n        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {\n          generateMipmap(_gl.TEXTURE_2D);\n        }\n      }\n\n      state.unbindTexture();\n    } else {\n      let glTextureType = _gl.TEXTURE_2D;\n\n      if (isRenderTarget3D) {\n        // Render targets containing layers, i.e: Texture 3D and 2d arrays\n        if (isWebGL2) {\n          const isTexture3D = texture.isDataTexture3D;\n          glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;\n        } else {\n          console.warn('THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.');\n        }\n      }\n\n      state.bindTexture(glTextureType, textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, texture, supportsMips);\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType);\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(glTextureType);\n      }\n\n      state.unbindTexture();\n    } // Setup depth and stencil buffers\n\n\n    if (renderTarget.depthBuffer) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n\n  function updateRenderTargetMipmap(renderTarget) {\n    const supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;\n    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];\n\n    for (let i = 0, il = textures.length; i < il; i++) {\n      const texture = textures[i];\n\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\n\n        const webglTexture = properties.get(texture).__webglTexture;\n\n        state.bindTexture(target, webglTexture);\n        generateMipmap(target);\n        state.unbindTexture();\n      }\n    }\n  }\n\n  function updateMultisampleRenderTarget(renderTarget) {\n    if (renderTarget.useRenderbuffer) {\n      if (isWebGL2) {\n        const width = renderTarget.width;\n        const height = renderTarget.height;\n        let mask = _gl.COLOR_BUFFER_BIT;\n        const invalidationArray = [_gl.COLOR_ATTACHMENT0];\n        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;\n\n        if (renderTarget.depthBuffer) {\n          invalidationArray.push(depthStyle);\n        }\n\n        if (!renderTarget.ignoreDepthForMultisampleCopy) {\n          if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;\n          if (renderTarget.stencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;\n        }\n\n        const renderTargetProperties = properties.get(renderTarget);\n        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);\n\n        if (renderTarget.ignoreDepthForMultisampleCopy) {\n          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);\n\n          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);\n        }\n\n        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);\n\n        _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);\n\n        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);\n        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);\n      } else {\n        console.warn('THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.');\n      }\n    }\n  }\n\n  function getRenderTargetSamples(renderTarget) {\n    return isWebGL2 && (renderTarget.useRenderbuffer || renderTarget.useRenderToTexture) ? Math.min(maxSamples, renderTarget.samples) : 0;\n  }\n\n  function updateVideoTexture(texture) {\n    const frame = info.render.frame; // Check the last frame we updated the VideoTexture\n\n    if (_videoTextures.get(texture) !== frame) {\n      _videoTextures.set(texture, frame);\n\n      texture.update();\n    }\n  }\n\n  function verifyColorSpace(texture, image) {\n    const encoding = texture.encoding;\n    const format = texture.format;\n    const type = texture.type;\n    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat) return image;\n\n    if (encoding !== LinearEncoding) {\n      // sRGB\n      if (encoding === sRGBEncoding) {\n        if (isWebGL2 === false) {\n          // in WebGL 1, try to use EXT_sRGB extension and unsized formats\n          if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {\n            texture.format = _SRGBAFormat; // it's not possible to generate mips in WebGL 1 with this extension\n\n            texture.minFilter = LinearFilter;\n            texture.generateMipmaps = false;\n          } else {\n            // slow fallback (CPU decode)\n            image = ImageUtils.sRGBToLinear(image);\n          }\n        } else {\n          // in WebGL 2 uncompressed textures can only be sRGB encoded if they have the RGBA8 format\n          if (format !== RGBAFormat || type !== UnsignedByteType) {\n            console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.');\n          }\n        }\n      } else {\n        console.error('THREE.WebGLTextures: Unsupported texture encoding:', encoding);\n      }\n    }\n\n    return image;\n  } // backwards compatibility\n\n\n  let warnedTexture2D = false;\n  let warnedTextureCube = false;\n\n  function safeSetTexture2D(texture, slot) {\n    if (texture && texture.isWebGLRenderTarget) {\n      if (warnedTexture2D === false) {\n        console.warn('THREE.WebGLTextures.safeSetTexture2D: don\\'t use render targets as textures. Use their .texture property instead.');\n        warnedTexture2D = true;\n      }\n\n      texture = texture.texture;\n    }\n\n    setTexture2D(texture, slot);\n  }\n\n  function safeSetTextureCube(texture, slot) {\n    if (texture && texture.isWebGLCubeRenderTarget) {\n      if (warnedTextureCube === false) {\n        console.warn('THREE.WebGLTextures.safeSetTextureCube: don\\'t use cube render targets as textures. Use their .texture property instead.');\n        warnedTextureCube = true;\n      }\n\n      texture = texture.texture;\n    }\n\n    setTextureCube(texture, slot);\n  } //\n\n\n  this.allocateTextureUnit = allocateTextureUnit;\n  this.resetTextureUnits = resetTextureUnits;\n  this.setTexture2D = setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  this.rebindTextures = rebindTextures;\n  this.setupRenderTarget = setupRenderTarget;\n  this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n  this.setupDepthRenderbuffer = setupDepthRenderbuffer;\n  this.setupFrameBufferTexture = setupFrameBufferTexture;\n  this.safeSetTexture2D = safeSetTexture2D;\n  this.safeSetTextureCube = safeSetTextureCube;\n}\n\nexport { WebGLTextures };","map":null,"metadata":{},"sourceType":"module"}